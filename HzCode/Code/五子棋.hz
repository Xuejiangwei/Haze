引 标准流

整数 棋盘长度 = 19
整数 棋子空 = 0
整数 棋子黑 = 1
整数 棋子白 = 2

整数 最小分 = -1
整数 零分 = 0
整数 阻挡一分 = 1
整数 一分 = 2
整数 阻挡二分 = 3
整数 二分 = 4
整数 阻挡三分 = 5
整数 三分 = 6
整数 阻挡四分 = 7
整数 四分 = 8
整数 五分 = 9

整数 玩家默认颜色 = 1
整数 AI默认颜色 = 2

类 五子棋
{
	数据
	{	
		公
		{
			整数 棋盘[棋盘长度][棋盘长度]
			整数 黑棋得分[棋盘长度][棋盘长度]
			整数 白棋得分[棋盘长度][棋盘长度]
		}
		
		私
		{
			整数 上边界
			整数 下边界
			整数 左边界
			整数 右边界

			整数 棋子数
			整数 棋子范围

			整数 放子计数
		}
	}

	函数
	{
		公
		{
			空 开始游戏()
			{
				清除()
				上边界 = 棋子数 / 2
				下边界 = 上边界
				左边界 = 上边界
				右边界 = 上边界

				棋子范围 = 4
			}

			空 清除()
			{
				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					循环(整数 乙 = 0, 乙 < 棋盘长度, 乙++)
					{
						棋盘[甲][乙] = 棋子空
						黑棋得分[甲][乙] = 最小分
						白棋得分[甲][乙] = 最小分
					}
				}

				放子计数 = 0
			}

			空 是否胜利(整数 颜色)
			{
				整数 最小横坐标 = 横 - 棋子范围 >= 0 ? 横 - 棋子范围 : 0
				整数 最大横坐标 = 横 + 棋子范围 < 棋盘长度 ? 横 + 棋子范围 : 棋盘长度
				整数 最小纵坐标 = 纵 - 棋子范围 >= 0 ? 纵 - 棋子范围 : 0
				整数 最大纵坐标 = 纵 + 棋子范围 < 棋盘长度 ? 纵 + 棋子范围 : 棋盘长度

				整数 (*得分数组)[棋子数] = 颜色 == 棋子黑 ? 黑棋得分 : 白棋得分 
				循环(整数 甲 = 最小横坐标, 甲 < 最大横坐标, 甲++)
				{
					循环(整数 乙 = 最小纵坐标, 乙 < 最大纵坐标, 乙++)
					{
						若(得分数组[甲][乙] >= 五分)
						{
							返 真
						}
					}
				}

				返 假
			}

			空 刷新打印()
			{
				打印("----")
				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					若(甲 < 10)
					{
						打印("%d    ", 甲)
					}
					否则
					{
						打印("%d   ", 甲)
					}
				}
				打印("\n")

				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					若(甲 < 10)
					{
						打印("%d   ", 甲)
					}
					否则
					{
						打印("%d  ", 甲)
					}

					循环(整数 乙 = 0, 乙 < 棋盘长度, 乙++)
					{
						整数 颜色 = 棋子空 //棋盘[甲][乙]
						
						若(颜色 == 棋子黑)
						{
							打印("%s", "黑")
						}
						否则 若(颜色 == 棋子白)
						{
							打印("%s", "白")
						}
						否则
						{
							打印("%s   ", "口")
						}
					}
					打印("\n\n")
				}
			}

			空 放子(整数 横坐标, 整数 纵坐标, 整数 颜色)
			{
				放子计数++
				棋盘[横坐标][纵坐标] = 颜色
				更新得分()
				更新边界()

				刷新打印()
			}
		}

		私
		{
			空 更新得分(整数 横, 整数 纵)
			{
				整数 最小横坐标 = 横 - 棋子范围 >= 0 ? 横 - 棋子范围 : 0
				整数 最大横坐标 = 横 + 棋子范围 < 棋盘长度 ? 横 + 棋子范围 : 棋盘长度
				整数 最小纵坐标 = 纵 - 棋子范围 >= 0 ? 纵 - 棋子范围 : 0
				整数 最大纵坐标 = 纵 + 棋子范围 < 棋盘长度 ? 纵 + 棋子范围 : 棋盘长度

				循环(整数 甲 = 最小横坐标, 甲 < 最大横坐标, 甲++)
				{
					循环(整数 乙 = 最小纵坐标, 乙 < 最大纵坐标, 乙++)
					{
						若(棋盘[甲][乙] == 棋子空)
						{
							黑棋得分[甲][乙] = 获得连线最大分(甲, 乙, 棋子黑)
							白棋得分[甲][乙] = 获得连线最大分(甲, 乙, 棋子白)
						}
					}
				}
			}

			空 更新边界(整数 横, 整数 纵)
			{
				若(横 <= 上边界)
				{
					上边界 = 横
					若(上边界 >= 1)
					{
						上边界--
					}
				}

				若(横 >= 下边界)
				{
					下边界 = 横
					若(下边界 < 棋盘长度 - 1)
					{
						棋盘长度++
					}
				}
				若(纵 <= 左边界)
				{
					左边界 = 纵
					若(左边界 >= 1)
					{
						左边界--
					}
				}
				若(纵 >= 右边界)
				{
					右边界 = 纵
					若(右边界 < 棋盘长度 - 1)
					{
						右边界++
					}
				}
			}

			整数 算取分数(整数 数量, 布尔 阻挡甲, 布尔 阻挡乙)
			{
				若(数量 >= 5)
				{
					返 五分
				}
				否则 若(数量 == 4)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡四分
					}
					否则
					{
						返 四分
					}
				}
				否则 若(数量 == 3)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡三分
					}
					否则
					{
						返 三分
					}
				}
				否则 若(数量 == 2)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡二分
					}
					否则
					{
						返 二分
					}
				}
				否则 若(数量 == 1)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡一分
					}
					否则
					{
						返 一分
					}
				}

				返 零分
			}

			整数 获得连线最大分(整数 横坐标, 整数 纵坐标, 整数 颜色)
			{
				若(颜色 == 棋子空)
				{
					返 零分
				}

				整数 列计数 = 1
				布尔 阻挡甲 = 假
				布尔 阻挡乙 = 假
				
				循环(整数 甲 = 纵坐标 + 1, 真, 甲++)
				{
					若(甲 >= 棋盘长度)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横坐标][甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻断甲 = 真
						}
						跳出
					}

					列计数++
				}

				循环(整数 甲 = 纵坐标 - 1, 真, 甲--)
				{
					若(甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横坐标][甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					列计数++
				}

				整数 分数甲 = 计算分数(列计数, 阻挡甲, 阻挡乙)

				若(分数甲 >= 五分)
				{
					返 分数甲
				}

				整数 行计数 = 1
				阻挡甲 = 假
				阻挡乙 = 假
				
				循环(整数 甲 = 横坐标 + 1, 真, 甲++)
				{
					若(甲 >= 棋盘长度)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻断甲 = 真
						}
						跳出
					}

					行计数++
				}

				循环(整数 甲 = 横坐标 - 1, 真, 甲--)
				{
					若(甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					行计数++
				}

				整数 分数乙 = 计算分数(行计数, 阻挡甲, 阻挡乙)

				若(分数乙 >= 五分)
				{
					返 分数乙
				}

				整数 斜向计数甲 = 1
				阻挡甲 = 假
				阻挡乙 = 假
				
				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 + 甲
					整数 纵甲 = 纵坐标 + 甲
					若(横甲 >= 棋盘长度 或 纵甲 >= 棋盘长度)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻断甲 = 真
						}
						跳出
					}

					斜向计数甲++
				}

				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 - 甲
					整数 纵甲 = 纵坐标 - 甲
					若(横甲 < 0 或 纵甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					斜向计数甲++
				}

				整数 分数丙 = 计算分数(斜向计数甲, 阻挡甲, 阻挡乙)

				若(分数丙 >= 五分)
				{
					返 分数乙
				}

				整数 斜向计数乙 = 1
				阻挡甲 = 假
				阻挡乙 = 假
				
				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 + 甲
					整数 纵甲 = 纵坐标 - 甲
					若(横甲 >= 棋盘长度 或 纵甲 >= 棋盘长度 或 横甲 < 0 或 纵甲 < 0)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻断甲 = 真
						}
						跳出
					}

					斜向计数甲++
				}

				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 - 甲
					整数 纵甲 = 纵坐标 + 甲
					若(横甲 >= 棋盘长度 或 纵甲 >= 棋盘长度 或 横甲 < 0 或 纵甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					斜向计数乙++
				}

				整数 分数丁 = 计算分数(斜向计数乙, 阻挡甲, 阻挡乙)

				若(分数丁 >= 五分)
				{
					返 分数乙
				}

				整数 最大分数 = 分数甲
				若(分数乙 > 最大)
				{
					最大分数 = 分数乙
				} 

				若(分数丙 > 最大)
				{
					最大分数 = 分数丙
				}

				若(分数丁 > 最大)
				{
					最大分数 = 分数丁
				}

				返 最大分数
			}

			空 模拟计算AI放子(整数* 位置甲, 整数* 乙, 整数 颜色)
			{
				若(放子计数 < 2)
				{
					整数 横坐标 = 棋子数 / 2
					整数 纵坐标 = 横坐标

					若(棋子[横坐标][纵坐标] == 棋子空)
					{
						*位置甲 = 横坐标
						*位置乙 = 纵坐标
					}
					否则
					{
						横坐标 = 棋子数 / 4
						纵坐标 = 横坐标

						*位置甲 = 横坐标
						*位置乙 = 纵坐标
					}
				}

				整数 (*得分数组)[棋子数] = 颜色 == 棋子黑 ? 黑棋得分 : 白棋得分 
				整数 AI得分 = 最小分
				循环(整数 甲 = 左边界, 甲 < 右边界, 甲++)
				{
					循环(整数 乙 = 上边界, 乙 < 下边界, 乙++)
					{
						若(棋子[甲][乙] == 棋子空)
						{
							整数 临时分 = 得分数组[甲][乙]
							若(临时分 == 最小分)
							{
								临时分 = 获得连线最大分(甲, 乙, 颜色)
							}

							若(临时分 > AI得分)
							{
								AI得分 = 临时分
								*位置甲 = 甲
								*位置乙 = 乙

								若(AI得分 >= 五分)
								{
									返
								}
							}
						}
					}
				}

				整数 (*对手得分数组)[棋子数] = 颜色 == 棋子黑 ? 白棋得分 : 黑棋得分
				整数 对手得分 = 最小分
				循环(整数 甲 = 左边界, 甲 < 右边界, 甲++)
				{
					循环(整数 乙 = 上边界, 乙 < 下边界, 乙++)
					{
						若(棋子[甲][乙] == 棋子空)
						{
							整数 临时分 = 得分数组[甲][乙]
							若(临时分 == 最小分)
							{
								临时分 = 获得连线最大分(甲, 乙, 颜色)
							}

							若(临时分 > 对手得分)
							{
								对手得分 = 临时分
								
								若(对手得分 > AI得分)
								{
									*位置甲 = 甲
									*位置乙 = 乙
									若(对手得分 >= 五分)
									{
										返
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


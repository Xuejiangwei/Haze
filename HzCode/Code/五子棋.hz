引 标准流

整数 棋盘长度 = 19
整数 棋子空 = 0
整数 棋子黑 = 1
整数 棋子白 = 2

整数 最小分 = 0
整数 零分 = 1
整数 阻挡一分 = 2
整数 一分 = 3
整数 阻挡二分 = 4
整数 二分 = 5
整数 阻挡三分 = 6
整数 三分 = 7
整数 阻挡四分 = 8
整数 四分 = 9
整数 五分 = 10

整数 玩家默认颜色 = 1
整数 AI默认颜色 = 2

类 五子棋
{
	数据
	{	
		公
		{
			整数 棋盘[19][19]
			整数 黑棋得分[19][19]
			整数 白棋得分[19][19]
		}
		
		私
		{
			整数 上边界
			整数 下边界
			整数 左边界
			整数 右边界

			整数 棋子范围

			整数 放子计数
			整数 打印连线
		}
	}

	函数
	{
		公
		{
			空 清除()
			{
				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					循环(整数 乙 = 0, 乙 < 棋盘长度, 乙++)
					{
						棋盘[甲][乙] = 棋子空
						黑棋得分[甲][乙] = 最小分
						白棋得分[甲][乙] = 最小分
					}
				}
			}
			
			空 开始游戏()
			{
				清除()
				上边界 = 棋盘长度 / 2
				下边界 = 上边界
				左边界 = 上边界
				右边界 = 上边界

				棋子范围 = 19
				放子计数 = 0
				打印连线 = 0
				打印("开始游戏 横坐标方向向右 竖坐标方向向下\n")
			}

			布尔 是否胜利(整数 颜色)
			{
				整数 (*得分数组)[19] = 颜色 == 棋子黑 ? 黑棋得分 : 白棋得分 
				循环(整数 甲 = 左边界, 甲 <= 右边界, 甲++)
				{
					循环(整数 乙 = 上边界, 乙 <= 下边界, 乙++)
					{
						若(得分数组[甲][乙] >= 五分)
						{
							若(棋盘[甲][乙] == 颜色)
							{
								打印("已经获得胜利 %d %d\n", 得分数组[甲][乙], 五分)
								返 真
							}
						}
					}
				}

				打印("未获得胜利\n")
				返 假
			}

			空 刷新打印()
			{
				打印("----")
				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					若(甲 < 10)
					{
						打印("%d    ", 甲)
					}
					否则
					{
						打印("%d   ", 甲)
					}
				}
				打印("\n")

				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					若(甲 < 10)
					{
						打印("%d   ", 甲)
					}
					否则
					{
						打印("%d  ", 甲)
					}

					循环(整数 乙 = 0, 乙 < 棋盘长度, 乙++)
					{
						//整数 颜色 = 棋盘[甲][乙]
						整数 颜色 = 棋盘[乙][甲]
						
						若(颜色 == 棋子黑)
						{
							打印("%s   ", "黑")
						}
						否则 若(颜色 == 棋子白)
						{
							打印("%s   ", "白")
						}
						否则
						{
							打印("%s   ", "口")
						}
					}

					打印("\n\n")
				}
			}

			空 打印得分(整数 颜色)
			{
				打印("打印得分\n")
				打印("----")
				
				整数 (*得分数组)[19] = 颜色 == 棋子黑 ? 黑棋得分 : 白棋得分 
				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					若(甲 < 10)
					{
						打印("%d    ", 甲)
					}
					否则
					{
						打印("%d   ", 甲)
					}
				}
				打印("\n")

				循环(整数 甲 = 0, 甲 < 棋盘长度, 甲++)
				{
					若(甲 < 10)
					{
						打印("%d   ", 甲)
					}
					否则
					{
						打印("%d  ", 甲)
					}

					循环(整数 乙 = 0, 乙 < 棋盘长度, 乙++)
					{
						若(得分数组[乙][甲] < 10)
						{
							打印("%d    ", 得分数组[乙][甲])
						}
						否则
						{
							打印("%d  ", 得分数组[乙][甲])
						}
					}
					打印("\n\n")
				}
			}

			空 放子(整数 横坐标, 整数 纵坐标, 整数 颜色)
			{
				放子计数++
				棋盘[横坐标][纵坐标] = 颜色

				打印("放子数 %d  横坐标 %d 纵坐标 %d 颜色 %d %d\n", 放子计数, 横坐标, 纵坐标, 颜色, 棋盘[横坐标][纵坐标])

				更新得分(横坐标, 纵坐标)
				更新边界(纵坐标, 横坐标)

				刷新打印()
				打印得分(颜色)
			}
		}

		私
		{
			空 更新得分(整数 横, 整数 纵)
			{
				整数 最小横坐标 = 横 - 棋子范围 >= 0 ? 横 - 棋子范围 : 0
				整数 最大横坐标 = 横 + 棋子范围 < 棋盘长度 ? 横 + 棋子范围 : 棋盘长度
				整数 最小纵坐标 = 纵 - 棋子范围 >= 0 ? 纵 - 棋子范围 : 0
				整数 最大纵坐标 = 纵 + 棋子范围 < 棋盘长度 ? 纵 + 棋子范围 : 棋盘长度

				打印("打印得分 最小横坐标 %d 最大横坐标 %d 最小纵坐标 %d 最大纵坐标 %d\n", 最小横坐标, 最大横坐标, 最小纵坐标, 最大纵坐标)
				循环(整数 甲 = 最小横坐标, 甲 < 最大横坐标, 甲++)
				{
					循环(整数 乙 = 最小纵坐标, 乙 < 最大纵坐标, 乙++)
					{
						若(棋盘[甲][乙] == 棋子空)
						{
							若(甲 == 11 且 乙 == 6)
							{
								打印连线 = 1
							}

							黑棋得分[甲][乙] = 获得连线最大分(甲, 乙, 棋子黑)
							白棋得分[甲][乙] = 获得连线最大分(甲, 乙, 棋子白)

							若(打印连线 > 0)
							{
								打印连线 = 0
								打印("更新得分 甲 %d 乙 %d 黑棋得分 %d 白棋得分 %d\n",甲, 乙, 黑棋得分[甲][乙], 白棋得分[甲][乙])
							}
						}
					}
				}
			}

			空 更新边界(整数 横, 整数 纵)
			{
				打印("更新边界 开始 上边界 %d 下边界 %d 左边界 %d 右边界 %d 横坐标 %d 纵坐标 %d\n", 上边界, 下边界, 左边界, 右边界, 横, 纵)
				若(横 <= 上边界)
				{
					上边界 = 横
					若(上边界 >= 1)
					{
						上边界--
					}
				}

				若(横 >= 下边界)
				{
					下边界 = 横
					若(下边界 < 棋盘长度 - 1)
					{
						下边界++
					}
				}

				若(纵 <= 左边界)
				{
					左边界 = 纵
					若(左边界 >= 1)
					{
						左边界--
					}
				}

				若(纵 >= 右边界)
				{
					右边界 = 纵
					若(右边界 < 棋盘长度 - 1)
					{
						右边界++
					}
				}

				打印("更新边界 结束 上边界 %d 下边界 %d 左边界 %d 右边界 %d\n", 上边界, 下边界, 左边界, 右边界)
			}

			整数 算取分数(整数 数量, 布尔 阻挡甲, 布尔 阻挡乙)
			{
				若(数量 >= 5)
				{
					返 五分
				}
				否则 若(阻挡甲 且 阻挡乙)
				{
					返 零分
				}
				否则 若(数量 == 4)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡四分
					}
					否则
					{
						返 四分
					}
				}
				否则 若(数量 == 3)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡三分
					}
					否则
					{
						返 三分
					}
				}
				否则 若(数量 == 2)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡二分
					}
					否则
					{
						返 二分
					}
				}
				否则 若(数量 == 1)
				{
					若(阻挡甲 或 阻挡乙)
					{
						返 阻挡一分
					}
					否则
					{
						返 一分
					}
				}

				返 零分
			}

			整数 获得连线最大分(整数 横坐标, 整数 纵坐标, 整数 颜色)
			{
				若(打印连线 > 0)
				{
					打印("获得连线最大分 横 %d 纵 %d\n", 横坐标, 纵坐标)
				}
				若(颜色 == 棋子空)
				{
					返 零分
				}

				整数 列计数 = 1
				布尔 阻挡甲 = 假
				布尔 阻挡乙 = 假
				
				循环(整数 甲 = 纵坐标 + 1, 真, 甲++)
				{
					若(甲 >= 棋盘长度)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横坐标][甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡甲 = 真
						}
						跳出
					}

					列计数++
				}

				循环(整数 甲 = 纵坐标 - 1, 真, 甲--)
				{
					若(甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横坐标][甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					列计数++
				}

				整数 分数甲 = 算取分数(列计数, 阻挡甲, 阻挡乙)
				若(打印连线 > 0)
				{
					打印("算分1 %d %d 分数 %d 颜色 %d 计数 %d\n", 阻挡甲, 阻挡乙, 分数甲, 颜色, 列计数)
				}
				若(分数甲 >= 五分)
				{
					返 分数甲
				}

				整数 行计数 = 1
				阻挡甲 = 假
				阻挡乙 = 假
				
				循环(整数 甲 = 横坐标 + 1, 真, 甲++)
				{
					若(甲 >= 棋盘长度)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡甲 = 真
						}
						跳出
					}

					行计数++
				}

				循环(整数 甲 = 横坐标 - 1, 真, 甲--)
				{
					若(甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[甲][纵坐标]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					行计数++
				}

				整数 分数乙 = 算取分数(行计数, 阻挡甲, 阻挡乙)
				若(打印连线 > 0)
				{
					打印("算分2 %d %d 分数 %d 计数 %d\n", 阻挡甲, 阻挡乙, 分数乙, 行计数)
				}
				若(分数乙 >= 五分)
				{
					返 分数乙
				}

				整数 斜向计数甲 = 1
				阻挡甲 = 假
				阻挡乙 = 假
				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 + 甲
					整数 纵甲 = 纵坐标 + 甲
					若(横甲 >= 棋盘长度 或 纵甲 >= 棋盘长度)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横甲][纵甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡甲 = 真
						}
						跳出
					}

					斜向计数甲++
				}

				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 - 甲
					整数 纵甲 = 纵坐标 - 甲
					若(横甲 < 0 或 纵甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横甲][纵甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					斜向计数甲++
				}

				整数 分数丙 = 算取分数(斜向计数甲, 阻挡甲, 阻挡乙)
				若(打印连线 > 0)
				{
					打印("算分3 %d %d 分数 %d 计数 %d\n", 阻挡甲, 阻挡乙, 分数丙, 斜向计数甲)
				}
				若(分数丙 >= 五分)
				{
					返 分数丙
				}

				整数 斜向计数乙 = 1
				阻挡甲 = 假
				阻挡乙 = 假
				
				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 + 甲
					整数 纵甲 = 纵坐标 - 甲
					若(横甲 >= 棋盘长度 或 纵甲 >= 棋盘长度 或 横甲 < 0 或 纵甲 < 0)
					{
						阻挡甲 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横甲][纵甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡甲 = 真
						}
						跳出
					}

					斜向计数乙++
				}

				循环(整数 甲 = 1, 真, 甲++)
				{
					整数 横甲 = 横坐标 - 甲
					整数 纵甲 = 纵坐标 + 甲
					若(横甲 >= 棋盘长度 或 纵甲 >= 棋盘长度 或 横甲 < 0 或 纵甲 < 0)
					{
						阻挡乙 = 真
						跳出
					}

					整数 颜色甲 = 棋盘[横甲][纵甲]

					若(颜色甲 != 颜色)
					{
						若(颜色甲 != 棋子空)
						{
							阻挡乙 = 真
						}
						跳出
					}

					斜向计数乙++
				}

				整数 分数丁 = 算取分数(斜向计数乙, 阻挡甲, 阻挡乙)
				若(打印连线 > 0)
				{
					打印("算分4 %d %d 分数 %d 计数 %d\n", 阻挡甲, 阻挡乙, 分数丁, 斜向计数乙)
				}
				若(分数丁 >= 五分)
				{
					返 分数丁
				}

				整数 最大分数 = 分数甲
				若(分数乙 > 最大分数)
				{
					最大分数 = 分数乙
				} 

				若(分数丙 > 最大分数)
				{
					最大分数 = 分数丙
				}

				若(分数丁 > 最大分数)
				{
					最大分数 = 分数丁
				}

				返 最大分数
			}

			空 模拟计算AI放子(整数* 位置甲, 整数* 位置乙, 整数 颜色)
			{
				若(放子计数 < 2)
				{
					整数 横坐标 = 棋盘长度 / 2
					整数 纵坐标 = 横坐标

					若(棋盘[横坐标][纵坐标] == 棋子空)
					{
						(*位置甲) = 横坐标
						(*位置乙) = 纵坐标
					}
					否则
					{
						横坐标 = 棋盘长度 / 4
						纵坐标 = 横坐标

						(*位置甲) = 横坐标
						(*位置乙) = 纵坐标
					}

					返
				}

				整数 (*得分数组)[19] = 颜色 == 棋子黑 ? 黑棋得分 : 白棋得分 
				整数 AI得分 = 最小分
				循环(整数 甲 = 左边界, 甲 <= 右边界, 甲++)
				{
					循环(整数 乙 = 上边界, 乙 <= 下边界, 乙++)
					{
						若(棋盘[甲][乙] == 棋子空)
						{
							整数 临时分 = 得分数组[甲][乙]
							若(临时分 == 最小分)
							{
								临时分 =  获得连线最大分(甲, 乙, 颜色)
							}

							若(临时分 > AI得分)
							{
								AI得分 = 临时分
								(*位置甲) = 甲
								(*位置乙) = 乙

								若(AI得分 >= 五分)
								{
									返
								}
							}
						}
					}
				}

				打印("AI模拟得分 %d\n", AI得分)
				打印连线 = 1
				整数 (*对手得分数组)[19] = 颜色 == 棋子黑 ? 白棋得分 : 黑棋得分
				整数 对手颜色 = 颜色 == 棋子黑 ? 棋子白 : 棋子黑
				整数 对手得分 = 最小分
				循环(整数 甲 = 左边界, 甲 <= 右边界, 甲++)
				{
					循环(整数 乙 = 上边界, 乙 <= 下边界, 乙++)
					{
						若(棋盘[甲][乙] == 棋子空)
						{
							整数 临时分 = 对手得分数组[甲][乙]
							若(临时分 == 最小分)
							{
								临时分 = 获得连线最大分(甲, 乙, 对手颜色)
							}

							打印("玩家模拟得分 临时分 %d 对手得分 %d 横坐标 %d 纵坐标 %d\n", 临时分, 对手得分, 甲, 乙)
							若(临时分 > 对手得分)
							{
								对手得分 = 临时分
								
								若(对手得分 > AI得分)
								{
									打印("获得新坐标 %d %d \n", 甲, 乙)
									(*位置甲) = 甲
									(*位置乙) = 乙
									若(对手得分 >= 五分)
									{
										打印("AI模拟 对手得分 %d\n", 对手得分)
										打印连线 = 0
										返
									}
								}
							}
						}
					}
				}

				打印连线 = 0
			}
		}
	}
}

